<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Camera Models: Mathematical Foundations</title>
  <meta name="description" content="Master the mathematical foundations of camera models">
  
  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['$$','$$']],
        processEscapes: true
      }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.7;
      color: #222;
      background: #fff;
      max-width: 820px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header */
    header {
      text-align: center;
      margin-bottom: 40px;
      padding: 20px 0;
      border-bottom: 2px solid #A6372A;
    }

    h1 {
      color: #A6372A;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #666;
      font-size: 1.1rem;
      font-weight: 400;
    }

    /* Navigation */
    nav {
      margin: 16px 0 24px;
      padding: 0;
    }

    nav a {
      color: #A6372A;
      text-decoration: none;
      margin-right: 20px;
      font-weight: 500;
    }

    nav a:hover {
      text-decoration: underline;
    }

    /* Main content */
    main {
      background: transparent;
      padding: 0;
      border-radius: 0;
      box-shadow: none;
      margin-bottom: 40px;
    }

    /* Typography */
    h2 {
      color: #A6372A;
      font-size: 1.8rem;
      font-weight: 600;
      margin: 30px 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    h3 {
      color: #444;
      font-size: 1.4rem;
      font-weight: 600;
      margin: 25px 0 10px 0;
    }

    h4 {
      color: #555;
      font-size: 1.2rem;
      font-weight: 600;
      margin: 20px 0 10px 0;
    }

    p {
      margin-bottom: 14px;
      font-size: 1.02rem;
      line-height: 1.8;
    }

    ul, ol {
      margin: 15px 0;
      padding-left: 30px;
    }

    li {
      margin-bottom: 8px;
      line-height: 1.6;
    }

    strong {
      color: #A6372A;
      font-weight: 600;
    }

    em {
      font-style: italic;
      color: #666;
    }

    /* Dividers */
    hr {
      border: none;
      height: 1px;
      background: #eee;
      margin: 30px 0;
    }

    /* Code */
    code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #e83e8c;
      font-size: 0.9rem;
    }

    pre {
      background: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 18px 0;
    }

    pre code {
      background: none;
      padding: 0;
      color: #333;
    }

    /* Math styling */
    .math-display {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #A6372A;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 18px 0;
      background: white;
      border: 1px solid #eee;
    }

    th {
      background: #A6372A;
      color: white;
      padding: 10px 12px;
      text-align: left;
      font-weight: 600;
    }

    td {
      padding: 10px 12px;
      border-bottom: 1px solid #eee;
    }

    tr:nth-child(even) {
      background: #fafafa;
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #A6372A;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 20px;
      color: #666;
      border-top: 1px solid #eee;
    }

    footer a {
      color: #A6372A;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      body {
        padding: 15px;
      }

      main {
        padding: 25px;
      }

      h1 {
        font-size: 2rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      h3 {
        font-size: 1.2rem;
      }

      nav {
        text-align: center;
      }

      nav a {
        display: block;
        margin: 5px 0;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 10px;
      }

      main {
        padding: 20px;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.3rem;
      }

      h3 {
        font-size: 1.1rem;
      }

      ul, ol {
        padding-left: 20px;
      }
    }

    /* Print styles */
    @media print {
      body {
        background: white;
        max-width: none;
        padding: 0;
      }

      main {
        box-shadow: none;
        padding: 0;
      }

      nav, footer {
        display: none;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Camera Models: Mathematical Foundations</h1>
    <p class="subtitle">A comprehensive guide to understanding camera geometry and projection</p>
  </header>

  <nav>
    <a href="/blogs/">‚Üê Back to Tutorials</a>
    <a href="/">Portfolio</a>
  </nav>

  <main>
    <div id="tutorial-content">
      <div class="loading">
        <div class="spinner"></div>
        <p>Loading tutorial content...</p>
      </div>
    </div>
  </main>

  <footer>
    <p>&copy; 2024 Muhammad Usama Saleem. <a href="/blogs/">Back to Tutorials</a></p>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script id="tutorial-md" type="text/plain">
# üìñ Table of Contents ‚Äî Understanding Camera Models in Detail

---

## Part I: Foundations of Camera Models

1. **Introduction to Camera Models**
   * Why do we need camera models?
   * Applications in computer vision, robotics, AR/VR
   * Historical note: pinhole to modern digital cameras

2. **Geometry of Image Formation**
   * Light, rays, and projection
   * The concept of the optical center
   * The image plane vs. the sensor plane

3. **Homogeneous Coordinates**
   * Why we use homogeneous coordinates
   * Representing points, lines, and transformations
   * Projective geometry basics

---

## Part II: Classical Camera Models

4. **The Pinhole Camera Model**
   * Basic setup and assumptions
   * Perspective projection equations
   * Image inversion and virtual image plane
   * Aperture size trade-offs

5. **Lens-Based Models**
   * The thin lens equation
   * Depth of field and focus
   * Lens distortions (barrel, pincushion, tangential)

6. **Alternative Simplified Models**
   * Weak perspective model
   * Orthographic projection
   * Scaled orthographic (paraperspective)
   * When approximations are useful

---

## Part III: Mathematical Formulation of Camera Projection

7. **Extrinsic Parameters (World ‚Üí Camera)**
   * Camera coordinate system
   * Rotation matrix $R$
   * Translation vector $t$
   * Rigid body transformation

8. **Intrinsic Parameters (Camera ‚Üí Pixels)**
   * Effective focal lengths $f_x, f_y$
   * Principal point $(c_x, c_y)$
   * Skew and pixel aspect ratio
   * The calibration matrix $K$

9. **The Full Camera Matrix**
   * Derivation: $P = K [R|t]$
   * Properties and degrees of freedom
   * Geometric interpretation

10. **Projection in Homogeneous Coordinates**
    * Matrix form of projection
    * Perspective divide
    * From 3D points to 2D pixels

---

## Part IV: Practical Considerations in Real Cameras

11. **Lens Distortion Models**
    * Radial distortion
    * Tangential distortion
    * Modeling and correction

12. **Sensor Characteristics**
    * Discretization into pixels
    * Noise and quantization
    * Rolling shutter effects

13. **Multi-Camera Systems**
    * Stereo geometry and epipolar constraint
    * Structure from motion (SfM)
    * Camera networks and panoramic cameras

---

## Part V: Camera Calibration

14. **Why Calibration Matters**
    * Estimating intrinsics and extrinsics
    * Applications in measurement and 3D vision

15. **Linear Camera Calibration**
    * Direct Linear Transform (DLT)
    * Requirements and degenerate cases

16. **Nonlinear Optimization (Bundle Adjustment)**
    * Reprojection error minimization
    * Distortion parameter estimation

17. **Practical Calibration Pipelines**
    * Checkerboard calibration
    * OpenCV implementation
    * Evaluating calibration accuracy

---

## Part VI: Advanced Topics

18. **Special Camera Models**
    * Fish-eye cameras
    * Catadioptric (mirror + lens) systems
    * Omnidirectional cameras

19. **Camera Model Extensions**
    * Projective ambiguity and self-calibration
    * Multi-view geometry basics
    * Absolute vs. relative camera pose

20. **Modern Applications of Camera Models**
    * Augmented reality & pose estimation
    * SLAM and visual odometry
    * Neural rendering (NeRFs, differentiable cameras)

---

‚ö° This TOC builds from **basic geometry ‚Üí classical models ‚Üí full camera matrix ‚Üí calibration ‚Üí advanced models and applications**.

# üì∑ Part I: Foundations of Camera Models

---

## 1. **Introduction to Camera Models**

### üîç Why Do We Need Camera Models?

In computer vision, the camera is the interface between the **3D world** and a **2D digital image**. A **camera model** is a mathematical abstraction that describes this transformation.

Mathematically, a 3D point

$$
X = (X, Y, Z, 1)^T
$$

is projected to a 2D pixel

$$
x = (u, v, 1)^T
$$

through a **camera projection function**:

$$
x \sim P X
$$

where $P \in \mathbb{R}^{3 \times 4}$ is the **camera matrix**.

Without a model, tasks like 3D reconstruction, augmented reality overlays, or robot navigation would be impossible ‚Äî because we couldn't reason how the 2D images relate back to the 3D world.

**The Fundamental Problem:**
The camera projection is a **many-to-one mapping** - infinitely many 3D points can project to the same 2D pixel. This is why we need sophisticated algorithms and multiple views to recover 3D information.

**Example:**
Consider a point at $(X, Y, Z)$ and another at $(2X, 2Y, 2Z)$. Both project to the same pixel $(u, v)$ under perspective projection, demonstrating the loss of depth information.

### ‚öôÔ∏è Applications in Vision and Robotics

**Computer Vision Applications:**
* **3D Reconstruction**: Building 3D models from multiple 2D images
* **Depth Estimation**: Computing distance to objects using stereo or monocular cues
* **Object Recognition**: Understanding object pose and orientation in 3D space
* **Image Stitching**: Creating panoramas by understanding camera geometry

**Robotics Applications:**
* **Visual SLAM**: Simultaneous Localization and Mapping using cameras
* **Robot Navigation**: Path planning and obstacle avoidance
* **Manipulation**: Precise positioning of robotic arms using visual feedback
* **Autonomous Vehicles**: Understanding the 3D environment from camera feeds

**AR/VR Applications:**
* **Pose Estimation**: Tracking camera position for overlaying graphics
* **Spatial Mapping**: Understanding the physical environment
* **Hand Tracking**: Precise hand pose estimation for interaction
* **Eye Tracking**: Understanding user gaze direction

**Industrial/Medical Applications:**
* **Photogrammetry**: Creating accurate 3D measurements from images
* **Medical Imaging**: Understanding camera geometry in surgical navigation
* **Quality Control**: Precise measurement and inspection
* **Reverse Engineering**: Reconstructing 3D models from photographs

### üï∞ Historical Note: From Pinhole to Digital Cameras

**Ancient Origins (5th century BCE):**
* **Mozi (China)**: First documented description of pinhole camera effects
* **Aristotle (Greece)**: Observed that light passing through small holes creates inverted images
* **Camera Obscura**: Used by artists and scientists for centuries

**Renaissance Perspective (15th century):**
* **Leon Battista Alberti**: Published "De Pictura" (1435), formalizing perspective geometry
* **Filippo Brunelleschi**: Demonstrated mathematical principles of perspective in art
* **Linear Perspective**: Established the foundation for modern camera models

**19th‚Äì20th Century Developments:**
* **Photographic Film**: Daguerreotype (1839) to modern film cameras
* **Glass Lenses**: Replaced pinholes for better light collection
* **Optical Theory**: Maxwell, Helmholtz, and others developed wave optics
* **Photogrammetry**: Mathematical methods for 3D reconstruction from photos

**Modern Digital Era:**
* **CCD/CMOS Sensors**: Replaced film with digital sensors (1970s onwards)
* **Digital Signal Processing**: Enabled real-time camera calibration and correction
* **Computer Vision**: Algorithms for automatic camera modeling and calibration
* **Mobile Cameras**: Ubiquitous cameras with sophisticated computational photography

**The Mathematical Legacy:**
Despite technological advances, the **pinhole camera model** remains the mathematical foundation. Modern cameras add lens distortions and sensor characteristics, but the core projection geometry is unchanged.

### üî¨ Mathematical Foundations

**Coordinate Systems:**
* **World Coordinates**: Global reference frame $(X_w, Y_w, Z_w)$
* **Camera Coordinates**: Local camera frame $(X_c, Y_c, Z_c)$
* **Image Coordinates**: 2D image plane $(x_i, y_i)$
* **Pixel Coordinates**: Discrete sensor array $(u, v)$

**The Projection Pipeline:**
1. **World ‚Üí Camera**: Rigid body transformation $[R|t]$
2. **Camera ‚Üí Image**: Perspective projection $/Z_c$
3. **Image ‚Üí Pixels**: Intrinsic transformation $K$

**Degrees of Freedom:**
* **Extrinsic**: 6 DOF (3 rotation + 3 translation)
* **Intrinsic**: 5 DOF (2 focal lengths + 2 principal point + 1 skew)
* **Total**: 11 DOF up to scale

**Scale Ambiguity:**
The camera matrix is defined up to scale - multiplying $P$ by any non-zero scalar gives the same projection. This is why we need calibration or multiple views to recover metric scale.

---

## 2. **Geometry of Image Formation**

### üåû Light, Rays, and Projection

* Each **3D point** emits or reflects light rays in all directions.
* The **camera aperture (pinhole)** restricts rays so that exactly **one ray per 3D point** reaches the image plane.
* This ensures a **unique mapping**: one world point ‚Üí one image point.

**Mathematical Setup:**
Let the **camera coordinate system** have origin at the optical center $O$, with the $Z$-axis pointing forward.
A world point in camera coordinates is

$$
X_c = (X_c, Y_c, Z_c)^T
$$

The ray from $O$ through $X_c$ intersects the **image plane** at distance $f$ (focal length) along the $Z$-axis.

By similar triangles (see diagram placeholder below):

$$
x_i = \frac{f X_c}{Z_c}, \quad y_i = \frac{f Y_c}{Z_c}
$$

This is the **perspective projection equation**.

### üéØ The Concept of the Optical Center

* The **optical center** (camera center) is the point where all rays converge.
* In the pinhole model, it's a single idealized point; in real cameras, it approximates the entrance pupil center.

### üñº The Image Plane vs. the Sensor Plane

* In pure geometry, the **image plane** is placed *behind* the pinhole at distance $f$ ‚Üí inverted image.
* Equivalently, a **virtual image plane** in front of the pinhole yields the same math up to a reflection.
* In real cameras, the **sensor plane** (CCD/CMOS) is a discrete pixel array; mapping to pixels is handled by the **intrinsic matrix** $K$.

### üî¨ Ray Tracing Fundamentals

**Ray Definition:**
A ray is a straight line extending from a point in a specific direction. In camera geometry, we consider rays from the optical center through scene points.

**Ray Equation:**
For a ray from optical center $O$ through point $X_c$:
$$
\mathbf{r}(t) = O + t \cdot \frac{X_c - O}{\|X_c - O\|}
$$

where $t$ is the parameter along the ray.

**Ray-Image Intersection:**
The ray intersects the image plane at $Z = f$:
$$
t = \frac{f}{Z_c}
$$

Substituting back gives the projection equations:
$$
x_i = \frac{f X_c}{Z_c}, \quad y_i = \frac{f Y_c}{Z_c}
$$

### üåà Optical Principles

**Light Propagation:**
* Light travels in straight lines in homogeneous media
* Reflection follows the law of reflection: angle of incidence = angle of reflection
* Refraction follows Snell's law: $n_1 \sin \theta_1 = n_2 \sin \theta_2$

**Aperture Effects:**
* **Small aperture**: Sharp image but dim (fewer rays)
* **Large aperture**: Bright image but blurred (multiple rays per point)
* **Optimal aperture**: Balance between brightness and sharpness

**Depth of Field:**
* Only objects at the focal distance are perfectly sharp
* Objects closer or farther blur into circles of confusion
* Depth of field increases with smaller aperture

### üìê Mathematical Derivation of Projection

**Step 1: Ray Direction**
Given a 3D point $X_c = (X_c, Y_c, Z_c)^T$ in camera coordinates, the ray direction is:
$$
\mathbf{d} = \frac{X_c}{\|X_c\|} = \frac{(X_c, Y_c, Z_c)^T}{\sqrt{X_c^2 + Y_c^2 + Z_c^2}}
$$

**Step 2: Ray Parameter**
The ray intersects the image plane at $Z = f$:
$$
\mathbf{r}(t) = (0, 0, 0)^T + t \cdot \mathbf{d} = (t \cdot d_x, t \cdot d_y, t \cdot d_z)^T
$$

Setting $Z = f$:
$$
t \cdot d_z = f \implies t = \frac{f}{d_z} = \frac{f \cdot \|X_c\|}{Z_c}
$$

**Step 3: Image Coordinates**
Substituting back:
$$
x_i = t \cdot d_x = \frac{f \cdot \|X_c\|}{Z_c} \cdot \frac{X_c}{\|X_c\|} = \frac{f X_c}{Z_c}
$$

$$
y_i = t \cdot d_y = \frac{f \cdot \|X_c\|}{Z_c} \cdot \frac{Y_c}{\|X_c\|} = \frac{f Y_c}{Z_c}
$$

### üîÑ Image Inversion and Virtual Image Plane

**Physical Image Plane (Behind Pinhole):**
* Image is inverted (upside down and left-right reversed)
* Mathematically: $x_i = -\frac{f X_c}{Z_c}, y_i = -\frac{f Y_c}{Z_c}$

**Virtual Image Plane (In Front):**
* Image has same orientation as scene
* Mathematically: $x_i = \frac{f X_c}{Z_c}, y_i = \frac{f Y_c}{Z_c}$

**Equivalence:**
Both models give equivalent results up to a coordinate transformation. The virtual image plane is often preferred for mathematical convenience.

### üéØ Optical Center in Real Cameras

**Pinhole Model:**
* Single point where all rays converge
* Mathematically idealized

**Real Lenses:**
* **Entrance Pupil**: The apparent aperture as seen from the object side
* **Exit Pupil**: The apparent aperture as seen from the image side
* **Nodal Points**: Points where light rays appear to cross without refraction

**Thin Lens Approximation:**
* Optical center at the center of the lens
* Valid when lens thickness is small compared to focal length

**Thick Lens Model:**
* Two principal planes
* Two nodal points
* More complex but more accurate for thick lenses

### üìä Sensor Characteristics

**Pixel Array:**
* Discrete grid of light-sensitive elements
* Each pixel has finite size and spacing
* Sampling converts continuous image to discrete pixels

**Pixel Response:**
* **Quantum Efficiency**: Fraction of photons converted to electrons
* **Fill Factor**: Fraction of pixel area that is light-sensitive
* **Dynamic Range**: Ratio of maximum to minimum detectable signal

**Color Sensing:**
* **Bayer Pattern**: Most common color filter array
* **RGB**: Red, Green, Blue filters
* **Demosaicing**: Interpolating full color from filtered data

### üîç Aperture Size Trade-offs

| Aperture Size | Brightness | Sharpness | Depth of Field |
|---------------|------------|-----------|----------------|
| **Small**     | Dim        | Sharp     | Large          |
| **Medium**    | Moderate   | Good      | Medium         |
| **Large**     | Bright     | Blurred   | Small          |

**Mathematical Relationship:**
* **F-number**: $f/\# = \frac{f}{D}$ where $D$ is aperture diameter
* **Exposure**: Proportional to $(f/\#)^{-2}$
* **Depth of Field**: Proportional to $f/\#$

**Optimal Aperture:**
* **Diffraction Limit**: Small apertures cause diffraction blur
* **Aberration Limit**: Large apertures cause lens aberrations
* **Sweet Spot**: Usually 2-3 stops down from maximum aperture

---

## 3. **Homogeneous Coordinates**

### ‚ö° Why Do We Use Homogeneous Coordinates?

Perspective projection involves **division by depth** $(Z_c)$:

$$
x_i = \frac{f X_c}{Z_c}, \quad y_i = \frac{f Y_c}{Z_c}
$$

This is nonlinear. But using **homogeneous coordinates**, we can write projection as a **linear matrix multiplication**.

### ‚úç Representing Points

* A 2D point $(u,v)$ is $(u,v,1)^T$.
* A 3D point $(X,Y,Z)$ is $(X,Y,Z,1)^T$.
* More generally: $ (x,y) \equiv (kx, ky, k) \ \forall k \neq 0 $ (defined up to scale).

### üìê Representing Lines and Transformations

* A 2D line $ax + by + c = 0$ is the vector $(a,b,c)^T$.
* Incidence: $l^T x = 0$ ‚áî point $x$ lies on line $l$.
* Geometric transforms (translation, rotation, projection) become matrices in homogeneous coordinates.

**Example: 2D translation by (t_x, t_y)**
```
T = [[1, 0, t_x],
     [0, 1, t_y],
     [0, 0,   1]]
x' = T x
```

### üåê Projective Geometry Basics

Homogeneous coordinates extend Euclidean geometry into **projective geometry**:

* **Points at infinity** and **vanishing points** are naturally represented.
* Camera projection matrix $P$ is a $3\times4$ projective transform, enabling the compact form $ \tilde{x} \sim P \tilde{X} $.

### üî¨ Mathematical Foundation

**Definition:**
Homogeneous coordinates represent points in projective space by adding an extra coordinate. A point $(x, y)$ in 2D becomes $(x, y, w)$ where $w \neq 0$.

**Equivalence Classes:**
Points $(x, y, w)$ and $(kx, ky, kw)$ represent the same point for any $k \neq 0$. This is written as $(x, y, w) \equiv (kx, ky, kw)$.

**Conversion:**
* **Euclidean to Homogeneous**: $(x, y) \rightarrow (x, y, 1)$
* **Homogeneous to Euclidean**: $(x, y, w) \rightarrow (x/w, y/w)$

### üìê 2D Homogeneous Coordinates

**Point Representation:**
* Euclidean point $(x, y)$ becomes $(x, y, 1)^T$
* Points at infinity have $w = 0$: $(x, y, 0)^T$

**Line Representation:**
* Line $ax + by + c = 0$ becomes vector $(a, b, c)^T$
* Line at infinity: $(0, 0, 1)^T$

**Point-Line Incidence:**
Point $x = (x, y, w)^T$ lies on line $l = (a, b, c)^T$ if and only if:
$$
l^T x = ax + by + cw = 0
$$

**Line Intersection:**
Two lines $l_1$ and $l_2$ intersect at point $x = l_1 \times l_2$

**Point Join:**
Two points $x_1$ and $x_2$ define line $l = x_1 \times x_2$

### üåç 3D Homogeneous Coordinates

**Point Representation:**
* Euclidean point $(X, Y, Z)$ becomes $(X, Y, Z, 1)^T$
* Points at infinity: $(X, Y, Z, 0)^T$

**Plane Representation:**
* Plane $aX + bY + cZ + d = 0$ becomes $(a, b, c, d)^T$

**Point-Plane Incidence:**
Point $X = (X, Y, Z, W)^T$ lies on plane $\pi = (a, b, c, d)^T$ if:
$$
\pi^T X = aX + bY + cZ + dW = 0
$$

### üîÑ Transformation Matrices

**2D Transformations:**

**Translation:**
$$
T = \begin{bmatrix} 
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1
\end{bmatrix}
$$

**Rotation (by angle $\theta$):**
$$
R = \begin{bmatrix} 
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

**Scaling:**
$$
S = \begin{bmatrix} 
s_x & 0 & 0 \\
0 & s_y & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

**Shear:**
$$
H = \begin{bmatrix} 
1 & h_x & 0 \\
h_y & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

**3D Transformations:**

**Translation:**
$$
T = \begin{bmatrix} 
I_{3\times3} & t \\
0^T & 1
\end{bmatrix}
$$

**Rotation:**
$$
R = \begin{bmatrix} 
R_{3\times3} & 0 \\
0^T & 1
\end{bmatrix}
$$

**General Rigid Body:**
$$
\begin{bmatrix} 
R & t \\
0^T & 1
\end{bmatrix}
$$

### üéØ Projective Transformations

**2D Projective Transform (Homography):**
$$
H = \begin{bmatrix} 
h_{11} & h_{12} & h_{13} \\
h_{21} & h_{22} & h_{23} \\
h_{31} & h_{32} & h_{33}
\end{bmatrix}
$$

**Properties:**
* Preserves straight lines
* Maps points to points
* 8 degrees of freedom (up to scale)

**3D Projective Transform:**
$$
H = \begin{bmatrix} 
H_{3\times3} & t \\
v^T & s
\end{bmatrix}
$$

**Properties:**
* 15 degrees of freedom (up to scale)
* Preserves planes
* Maps lines to lines

### üåê Points at Infinity

**2D Points at Infinity:**
* Represented as $(x, y, 0)^T$
* Direction vector $(x, y)^T$
* All parallel lines intersect at the same point at infinity

**3D Points at Infinity:**
* Represented as $(X, Y, Z, 0)^T$
* Direction vector $(X, Y, Z)^T$
* All parallel lines in 3D intersect at the same point at infinity

**Vanishing Points:**
* Points where parallel lines appear to converge
* Represented as points at infinity in the image
* Used in perspective drawing and 3D reconstruction

### üîç Practical Examples

**Example 1: Translation**
Point $(2, 3)$ translated by $(1, 2)$:
$$
\begin{bmatrix} 1 & 0 & 1 \\ 0 & 1 & 2 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 2 \\ 3 \\ 1 \end{bmatrix} = 
\begin{bmatrix} 3 \\ 5 \\ 1 \end{bmatrix} \rightarrow (3, 5)
$$

**Example 2: Rotation**
Point $(1, 0)$ rotated by $90¬∞$:
$$
\begin{bmatrix} 0 & -1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} 1 \\ 0 \\ 1 \end{bmatrix} = 
\begin{bmatrix} 0 \\ 1 \\ 1 \end{bmatrix} \rightarrow (0, 1)
$$

**Example 3: Perspective Projection**
3D point $(X, Y, Z)$ projected to 2D:
$$
\begin{bmatrix} f & 0 & 0 \\ 0 & f & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} X \\ Y \\ Z \end{bmatrix} = 
\begin{bmatrix} fX \\ fY \\ Z \end{bmatrix} \rightarrow (fX/Z, fY/Z)
$$

### üé® Geometric Interpretation

**Projective Space:**
* Extends Euclidean space with points at infinity
* Provides unified framework for affine and projective transformations
* Enables linear representation of perspective projection

**Duality:**
* In 2D: points ‚Üî lines
* In 3D: points ‚Üî planes
* Duality principle: any theorem about points has a dual theorem about lines/planes

**Cross Ratio:**
* Projective invariant for four collinear points
* Preserved under projective transformations
* Used in camera calibration and 3D reconstruction
  </script>
  <script>

    // Load and render tutorial content
    function loadTutorial() {
      try {
        const container = document.getElementById('tutorial-content');
        const mdNode = document.getElementById('tutorial-md');
        const tutorialContent = mdNode ? mdNode.textContent : '';
        
        // Configure marked
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: true
        });
        
        // Render markdown
        container.innerHTML = marked.parse(tutorialContent || '# Error\nContent missing.');
        
        // Add smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const target = document.querySelector(link.getAttribute('href'));
            if (target) {
              target.scrollIntoView({ behavior: 'smooth' });
            }
          });
        });
        
      } catch (error) {
        document.getElementById('tutorial-content').innerHTML = `
          <div style="text-align: center; padding: 40px; color: #666;">
            <h3>Error Loading Content</h3>
            <p>Sorry, the tutorial content could not be loaded.</p>
            <p><small>${error.message}</small></p>
          </div>
        `;
      }
    }

    // Load content when page loads
    document.addEventListener('DOMContentLoaded', loadTutorial);
  </script>
</body>
</html>
